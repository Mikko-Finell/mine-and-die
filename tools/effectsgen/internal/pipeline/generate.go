package pipeline

import (
	"bytes"
	"encoding/json"
	"sort"
	"strconv"
	"strings"
)

func generateEffectCatalogModule(definitions []contractDefinition, decls tsDeclarations, entries []catalogEntry) ([]byte, error) {
	var builder strings.Builder
	builder.WriteString("// Code generated by effectsgen. DO NOT EDIT.\n\n")

	for i, iface := range decls.Interfaces {
		if i > 0 {
			builder.WriteString("\n")
		}
		builder.WriteString("export interface ")
		builder.WriteString(iface.Name)
		builder.WriteString(" {\n")
		for _, field := range iface.Fields {
			builder.WriteString("  readonly ")
			builder.WriteString(field.Name)
			if field.Optional {
				builder.WriteString("?: ")
			} else {
				builder.WriteString(": ")
			}
			builder.WriteString(field.Type)
			builder.WriteString(";\n")
		}
		builder.WriteString("}\n")
	}

	if len(decls.Aliases) > 0 {
		if len(decls.Interfaces) > 0 {
			builder.WriteString("\n")
		}
		for i, alias := range decls.Aliases {
			if i > 0 {
				builder.WriteString("\n")
			}
			builder.WriteString("export type ")
			builder.WriteString(alias.Name)
			builder.WriteString(" = ")
			builder.WriteString(alias.Target)
			builder.WriteString(";\n")
		}
	}

	if len(decls.Interfaces) > 0 || len(decls.Aliases) > 0 {
		builder.WriteString("\n")
	}

	builder.WriteString("export type EffectContractMap = {\n")
	for _, def := range definitions {
		builder.WriteString("  readonly ")
		builder.WriteString(strconv.Quote(def.ID))
		builder.WriteString(": {\n")

		builder.WriteString("    readonly spawn: ")
		builder.WriteString(def.Spawn.TypeName)
		builder.WriteString(";\n")

		builder.WriteString("    readonly update: ")
		builder.WriteString(def.Update.TypeName)
		builder.WriteString(";\n")

		builder.WriteString("    readonly end: ")
		builder.WriteString(def.End.TypeName)
		builder.WriteString(";\n")

		builder.WriteString("  };\n")
	}
	builder.WriteString("};\n\n")

	builder.WriteString("export type EffectContractID = keyof EffectContractMap;\n\n")

	builder.WriteString("export type Phantom<T> = {\n")
	builder.WriteString("  readonly __phantom?: (t: T) => T;\n")
	builder.WriteString("};\n\n")

	builder.WriteString("export interface LifecyclePayloadMetadata<TPayload> extends Phantom<TPayload> {\n")
	builder.WriteString("  readonly hasPayload: boolean;\n")
	builder.WriteString("}\n\n")

	builder.WriteString("export interface EffectContractMetadata<TSpawn, TUpdate, TEnd> {\n")
	builder.WriteString("  readonly id: EffectContractID;\n")
	builder.WriteString("  readonly managedByClient: boolean;\n")
	builder.WriteString("  readonly spawn: LifecyclePayloadMetadata<TSpawn>;\n")
	builder.WriteString("  readonly update: LifecyclePayloadMetadata<TUpdate>;\n")
	builder.WriteString("  readonly end: LifecyclePayloadMetadata<TEnd>;\n")
	builder.WriteString("}\n\n")

	builder.WriteString("export type EffectContractMetadataMap = {\n")
	builder.WriteString("  readonly [TContract in EffectContractID]: EffectContractMetadata<\n")
	builder.WriteString("    EffectContractMap[TContract][\"spawn\"],\n")
	builder.WriteString("    EffectContractMap[TContract][\"update\"],\n")
	builder.WriteString("    EffectContractMap[TContract][\"end\"]\n")
	builder.WriteString("  >;\n")
	builder.WriteString("};\n\n")

	builder.WriteString("export const effectContracts = {\n")

	for _, def := range definitions {
		builder.WriteString("  ")
		builder.WriteString(strconv.Quote(def.ID))
		builder.WriteString(": {\n")

		builder.WriteString("    id: ")
		builder.WriteString(strconv.Quote(def.ID))
		builder.WriteString(",\n")

		builder.WriteString("    managedByClient: ")
		builder.WriteString(strconv.FormatBool(def.ClientOwned))
		builder.WriteString(",\n")

		builder.WriteString("    spawn: ")
		writeLifecycleMetadata(&builder, def.Spawn)
		builder.WriteString(",\n")

		builder.WriteString("    update: ")
		writeLifecycleMetadata(&builder, def.Update)
		builder.WriteString(",\n")

		builder.WriteString("    end: ")
		writeLifecycleMetadata(&builder, def.End)
		builder.WriteString(",\n")

		builder.WriteString("  },\n")
	}

	builder.WriteString("} as const satisfies EffectContractMetadataMap;\n\n")
	builder.WriteString("export type EffectContracts = typeof effectContracts;\n\n")

	builder.WriteString("export function getContractMeta<TContract extends EffectContractID>(\n")
	builder.WriteString("  contractId: TContract,\n")
	builder.WriteString("): EffectContractMetadataMap[TContract] {\n")
	builder.WriteString("  return effectContracts[contractId];\n")
	builder.WriteString("}\n\n")

	builder.WriteString("export type EffectCatalogEntry = {\n")
	builder.WriteString("  readonly contractId: string;\n")
	builder.WriteString("  readonly managedByClient: boolean;\n")
	builder.WriteString("  readonly definition: EffectDefinition;\n")
	builder.WriteString("  readonly blocks: Readonly<Record<string, unknown>>;\n")
	builder.WriteString("};\n\n")
	builder.WriteString("export const effectCatalog = {\n")

	for _, entry := range entries {
		if err := writeCatalogEntry(&builder, entry); err != nil {
			return nil, err
		}
	}

	builder.WriteString("} as const satisfies Record<string, EffectCatalogEntry>;\n\n")
	builder.WriteString("export type EffectCatalog = typeof effectCatalog;\n")

	return []byte(builder.String()), nil
}

func writeCatalogEntry(builder *strings.Builder, entry catalogEntry) error {
	builder.WriteString("  ")
	builder.WriteString(strconv.Quote(entry.ID))
	builder.WriteString(": {\n")

	indent := "    "
	builder.WriteString(indent)
	builder.WriteString(strconv.Quote("contractId"))
	builder.WriteString(": ")
	builder.WriteString(strconv.Quote(entry.ContractID))
	builder.WriteString(",\n")

	builder.WriteString(indent)
	builder.WriteString(strconv.Quote("managedByClient"))
	builder.WriteString(": ")
	builder.WriteString(strconv.FormatBool(entry.ManagedByClient))
	builder.WriteString(",\n")

	builder.WriteString(indent)
	builder.WriteString(strconv.Quote("definition"))
	builder.WriteString(": ")
	defValue, err := formatJSONValue(entry.Definition, indent+"  ")
	if err != nil {
		return err
	}
	builder.WriteString(defValue)
	builder.WriteString(",\n")

	if len(entry.Blocks) == 0 {
		builder.WriteString(indent)
		builder.WriteString(strconv.Quote("blocks"))
		builder.WriteString(": {},\n")
	} else {
		builder.WriteString(indent)
		builder.WriteString(strconv.Quote("blocks"))
		builder.WriteString(": {\n")
		blockIndent := indent + "  "
		keys := make([]string, 0, len(entry.Blocks))
		for key := range entry.Blocks {
			keys = append(keys, key)
		}
		sort.Strings(keys)
		for _, key := range keys {
			value, err := formatJSONValue(entry.Blocks[key], blockIndent+"  ")
			if err != nil {
				return err
			}
			builder.WriteString(blockIndent)
			builder.WriteString(strconv.Quote(key))
			builder.WriteString(": ")
			builder.WriteString(value)
			builder.WriteString(",\n")
		}
		builder.WriteString(indent)
		builder.WriteString("},\n")
	}

	builder.WriteString("  },\n")
	return nil
}

func formatJSONValue(raw json.RawMessage, indent string) (string, error) {
	trimmed := bytes.TrimSpace(raw)
	if len(trimmed) == 0 {
		return "null", nil
	}

	switch trimmed[0] {
	case '{', '[':
		var pretty bytes.Buffer
		if err := json.Indent(&pretty, trimmed, indent, "  "); err != nil {
			return "", err
		}
		value := pretty.String()
		if strings.HasPrefix(value, indent) {
			value = strings.TrimPrefix(value, indent)
		}
		return value, nil
	default:
		return string(trimmed), nil
	}
}

func writeLifecycleMetadata(builder *strings.Builder, binding payloadBinding) {
	builder.WriteString("{\n")
	builder.WriteString("      hasPayload: ")
	builder.WriteString(strconv.FormatBool(!binding.IsNoPayload))
	builder.WriteString(",\n")
	builder.WriteString("    }")
}
