package pipeline

import (
	"bytes"
	"encoding/json"
	"sort"
	"strconv"
	"strings"
)

func generateEffectCatalogModule(entries []catalogEntry) ([]byte, error) {
	var builder strings.Builder
	builder.WriteString("// Code generated by effectsgen. DO NOT EDIT.\n\n")
	builder.WriteString("export type EffectCatalogEntry = {\n")
	builder.WriteString("  readonly contractId: string;\n")
	builder.WriteString("  readonly definition: Readonly<Record<string, unknown>>;\n")
	builder.WriteString("  readonly blocks: Readonly<Record<string, unknown>>;\n")
	builder.WriteString("};\n\n")
	builder.WriteString("export const effectCatalog = {\n")

	for _, entry := range entries {
		if err := writeCatalogEntry(&builder, entry); err != nil {
			return nil, err
		}
	}

	builder.WriteString("} as const satisfies Record<string, EffectCatalogEntry>;\n\n")
	builder.WriteString("export type EffectCatalog = typeof effectCatalog;\n")

	return []byte(builder.String()), nil
}

func writeCatalogEntry(builder *strings.Builder, entry catalogEntry) error {
	builder.WriteString("  ")
	builder.WriteString(strconv.Quote(entry.ID))
	builder.WriteString(": {\n")

	indent := "    "
	builder.WriteString(indent)
	builder.WriteString(strconv.Quote("contractId"))
	builder.WriteString(": ")
	builder.WriteString(strconv.Quote(entry.ContractID))
	builder.WriteString(",\n")

	builder.WriteString(indent)
	builder.WriteString(strconv.Quote("definition"))
	builder.WriteString(": ")
	defValue, err := formatJSONValue(entry.Definition, indent+"  ")
	if err != nil {
		return err
	}
	builder.WriteString(defValue)
	builder.WriteString(",\n")

	if len(entry.Blocks) == 0 {
		builder.WriteString(indent)
		builder.WriteString(strconv.Quote("blocks"))
		builder.WriteString(": {},\n")
	} else {
		builder.WriteString(indent)
		builder.WriteString(strconv.Quote("blocks"))
		builder.WriteString(": {\n")
		blockIndent := indent + "  "
		keys := make([]string, 0, len(entry.Blocks))
		for key := range entry.Blocks {
			keys = append(keys, key)
		}
		sort.Strings(keys)
		for _, key := range keys {
			value, err := formatJSONValue(entry.Blocks[key], blockIndent+"  ")
			if err != nil {
				return err
			}
			builder.WriteString(blockIndent)
			builder.WriteString(strconv.Quote(key))
			builder.WriteString(": ")
			builder.WriteString(value)
			builder.WriteString(",\n")
		}
		builder.WriteString(indent)
		builder.WriteString("},\n")
	}

	builder.WriteString("  },\n")
	return nil
}

func formatJSONValue(raw json.RawMessage, indent string) (string, error) {
	trimmed := bytes.TrimSpace(raw)
	if len(trimmed) == 0 {
		return "null", nil
	}

	switch trimmed[0] {
	case '{', '[':
		var pretty bytes.Buffer
		if err := json.Indent(&pretty, trimmed, indent, "  "); err != nil {
			return "", err
		}
		value := pretty.String()
		if strings.HasPrefix(value, indent) {
			value = strings.TrimPrefix(value, indent)
		}
		return value, nil
	default:
		return string(trimmed), nil
	}
}
