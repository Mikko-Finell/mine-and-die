package pipeline

import (
	"os"
	"path/filepath"
	"testing"

	"mine-and-die/tools/effectsgen/internal/testutil"
)

func TestRunGeneratesEffectCatalogModule(t *testing.T) {
	tempDir := t.TempDir()
	contractsDir, registryPath := testutil.WriteContractFixtures(t, tempDir)

	definitionsPath := filepath.Join(tempDir, "definitions.json")
	definitions := `[
  {
    "id": "fireball",
    "contractId": "fireball",
    "definition": {
      "typeId": "fireball",
      "client": {"sendSpawn": true},
      "end": {"kind": 0}
    },
    "jsEffect": "projectile/fireball",
    "parameters": {"speed": 320}
  },
  {
    "id": "attack",
    "contractId": "attack",
    "definition": {
      "typeId": "attack",
      "end": {"kind": 1}
    }
  }
]`
	if err := os.WriteFile(definitionsPath, []byte(definitions), 0o644); err != nil {
		t.Fatalf("failed to write definitions stub: %v", err)
	}

	outputPath := filepath.Join(tempDir, "out", "effect-contracts.ts")
	opts := Options{
		ContractsDir:    contractsDir,
		RegistryPath:    registryPath,
		DefinitionsPath: definitionsPath,
		OutputPath:      outputPath,
	}

	if err := Run(opts); err != nil {
		t.Fatalf("Run returned error: %v", err)
	}

	data, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("failed to read generated output: %v", err)
	}

	expected := `// Code generated by effectsgen. DO NOT EDIT.

export interface AttackEndPayload {
  readonly reason: string;
  readonly notes?: string;
  readonly result: EndResult;
}

export interface AttackSpawnPayload {
  readonly instanceId: string;
  readonly location: Coordinates;
  readonly delivery: DeliveryKind;
}

export interface AttackUpdatePayload {
  readonly seq?: number;
  readonly params?: Readonly<Record<string, number>>;
  readonly origin?: Coordinates;
}

export interface Coordinates {
  readonly x: number;
  readonly y: number;
}

export type DeliveryKind = "melee" | "ranged";

export type EndResult = 0 | 1;

export type FireballEndPayload = AttackEndPayload;

export type FireballSpawnPayload = AttackSpawnPayload;

export type FireballUpdatePayload = AttackUpdatePayload;

export type EffectContractMap = {
  readonly "attack": {
    readonly spawn: AttackSpawnPayload;
    readonly update: AttackUpdatePayload;
    readonly end: AttackEndPayload;
  };
  readonly "fireball": {
    readonly spawn: FireballSpawnPayload;
    readonly update: FireballUpdatePayload;
    readonly end: FireballEndPayload;
  };
};

export type EffectContractID = keyof EffectContractMap;

export type Phantom<T> = {
  readonly __phantom?: (t: T) => T;
};

export interface LifecyclePayloadMetadata<TPayload> extends Phantom<TPayload> {
  readonly hasPayload: boolean;
}

export interface EffectContractMetadata<TSpawn, TUpdate, TEnd> {
  readonly id: EffectContractID;
  readonly managedByClient: boolean;
  readonly spawn: LifecyclePayloadMetadata<TSpawn>;
  readonly update: LifecyclePayloadMetadata<TUpdate>;
  readonly end: LifecyclePayloadMetadata<TEnd>;
}

export type EffectContractMetadataMap = {
  readonly [TContract in EffectContractID]: EffectContractMetadata<
    EffectContractMap[TContract]["spawn"],
    EffectContractMap[TContract]["update"],
    EffectContractMap[TContract]["end"]
  >;
};

export const effectContracts = {
  "attack": {
    id: "attack",
    managedByClient: true,
    spawn: {
      hasPayload: true,
    },
    update: {
      hasPayload: true,
    },
    end: {
      hasPayload: true,
    },
  },
  "fireball": {
    id: "fireball",
    managedByClient: false,
    spawn: {
      hasPayload: true,
    },
    update: {
      hasPayload: true,
    },
    end: {
      hasPayload: true,
    },
  },
} as const satisfies EffectContractMetadataMap;

export type EffectContracts = typeof effectContracts;

export function getContractMeta<TContract extends EffectContractID>(
  contractId: TContract,
): EffectContractMetadataMap[TContract] {
  return effectContracts[contractId];
}

export type EffectCatalogEntry = {
  readonly contractId: string;
  readonly managedByClient: boolean;
  readonly definition: EffectDefinition;
  readonly blocks: Readonly<Record<string, unknown>>;
};

export const effectCatalog = {
  "attack": {
    "contractId": "attack",
    "managedByClient": true,
    "definition": {
        "typeId": "attack",
        "end": {
          "kind": 1
        }
      },
    "blocks": {},
  },
  "fireball": {
    "contractId": "fireball",
    "managedByClient": false,
    "definition": {
        "typeId": "fireball",
        "client": {
          "sendSpawn": true
        },
        "end": {
          "kind": 0
        }
      },
    "blocks": {
      "jsEffect": "projectile/fireball",
      "parameters": {
          "speed": 320
        },
    },
  },
} as const satisfies Record<string, EffectCatalogEntry>;

export type EffectCatalog = typeof effectCatalog;
`

	if string(data) != expected {
		t.Fatalf("generated output mismatch\nexpected:\n%s\n\ngot:\n%s", expected, string(data))
	}
}
