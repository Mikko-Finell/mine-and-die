# Suspected bugs

1. **Broken version increments in world mutators**
   - **File(s):** `server/world_mutators.go`
   - **What it's about:** Helper functions such as `setActorPosition`, `setActorFacing`, `setActorIntent`, `setActorHealth`, `mutateActorInventory`, and `mutateActorEquipment` are supposed to bump the caller-provided `version *uint64` when they emit a patch.
   - **Why it's a problem:** Each helper uses the expression `*version++`. In Go this parses as `*(version++)`, which is illegal pointer arithmetic; the code will not compile once these helpers are exercised. Even if the compiler somehow tolerated it, the pointer would be advanced instead of the underlying counter, so entity versions would stop incrementing. Either way, the patch journal and diff stream would desynchronise because version numbers would never change when state mutates.

2. **Inventory diff check ignores fungibility keys**
   - **File(s):** `server/world_mutators.go`
   - **What it's about:** `mutateActorInventory` relies on `inventoriesEqual` to decide whether to emit a `PatchPlayerInventory`/`PatchNPCInventory` update after applying a mutation.
   - **Why it's a problem:** `inventoriesEqual` only compares slot indices, item types, and quantities. It skips `ItemStack.FungibilityKey`, which is the identity for non-stackable gear and tagged stacks. If a mutation swaps an equipped item for another copy with the same type but a different fungibility key (e.g., different affixes), the helper thinks nothing changed and suppresses the patch. Clients would keep rendering the old item even though the authoritative inventory now holds a different instance.

3. **Contract tick cadence knob is ignored**
   - **File(s):** `server/effects_contract.go`, `server/effects_manager.go`
   - **What it's about:** `EffectIntent` exposes a `TickCadence` field, suggesting contract-driven effects can throttle their update cadence.
   - **Why it's a problem:** The effect pipeline never consults `TickCadence`. `EffectManager.instantiateIntent` copies duration, params, delivery, etc., but no code stores or respects the cadence hint. Any intent that sets `tickCadence` in the payload will behave identically to one that omits it, so designers cannot slow down expensive effect hooks even though the contract advertises that ability.
   - **Status:** Fixed â€” cadence is now persisted per instance and OnTick/update emission follow the configured interval (`TestEffectManagerRespectsTickCadence`).

4. **Effect patches silently dropped during broadcast**
   - **File(s):** `server/hub.go`
   - **What it's about:** `Hub.marshalState` filters the drained patch list before encoding, keeping only entries whose `EntityID` is present in the "alive" map built from the current `players`, `npcs`, and `groundItems` slices.
   - **Why it's a problem:** Effect patches (e.g., from `SetEffectPosition` or `SetEffectParam`) use effect instance IDs, but those IDs are never added to the alive set. The filter strips every effect patch, so the client never sees contract-managed effect updates via the diff channel. Any server-side effect adjustments rely solely on keyframes, defeating the purpose of emitting effect patches in the first place.
