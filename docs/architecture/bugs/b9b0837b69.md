# Bug Review Scratchpad

## 1. Inventory patch equality ignores fungibility keys
- **File(s):** `server/world_mutators.go`
- **Code:** `inventoriesEqual` used by `World.mutateActorInventory`
- **Problem:** The equality check only compares slot index, item type, and quantity when deciding if an inventory mutation emitted a patch. It never looks at `ItemStack.FungibilityKey`, so server-side changes that swap a stack to a different fungibility key (e.g., distinct potion variants or durability buckets) will be treated as “no change” and skipped. That leaves the client with stale stack metadata even though the server mutated it.

## 2. Client inventory clones drop fungibility metadata
- **File(s):** `client/patches.js`
- **Code:** `cloneInventorySlots` (used by `createPlayerView` / patch hydration)
- **Problem:** The cloning helper rebuilds each slot with only `type` and `quantity`, discarding `fungibility_key` values that the server includes. Any unique stack separation that depends on the key (e.g., differentiating non-stackable gear instances) is lost the moment the client hydrates a snapshot or applies patches, so the UI can silently merge stacks that the server keeps distinct.

## 3. NPC gold pickups bypass inventory patching
- **File(s):** `server/effects.go`
- **Code:** `resolveMeleeImpact` branch that rewards owners when mining gold ore
- **Problem:** When a non-player actor mines a gold obstacle, the code writes directly to `owner.Inventory.AddStack(...)` instead of routing through `World.MutateNPCInventory`. That skips version bumps and patch emission, so the NPC’s inventory changes never reach subscribers, and downstream systems that rely on patches miss the update.

## 4. Broadcast logging leaks entire state payloads
- **File(s):** `server/hub.go`
- **Code:** `broadcastState` debug loop that scans for effect keywords before writing
- **Problem:** Every outbound message is scanned for strings like "blood-splatter" and, when found, the method logs the full JSON payload (`stdlog.Printf(..., data)`). Combat updates frequently contain those identifiers, so production logs will capture entire state snapshots (player positions, inventories, etc.) on every swing, flooding logs and exposing sensitive information.

