# Potential Bugs Review

## 1. Projectile velocity quantization loses direction
- **File(s):** `server/effects_manager.go`
- **Code:** `EffectManager.syncProjectileInstance`
- **Why it's a problem:** The hook copies projectile motion into the replicated `BehaviorState.Extra` and `Params` maps by rounding `effect.Projectile.VelocityUnitX`/`VelocityUnitY` to integers. Any projectile whose unit vector has non-integer components (for example, diagonal movement) will be reported to clients as travelling purely horizontal/vertical or even standing still when the component rounds to zero. That corrupts client-side playback, causes range calculations to diverge, and can desync follow-up contract logic that relies on the replicated direction.

## 2. Equip rollback drops items on inventory errors
- **File(s):** `server/world_equipment.go`
- **Code:** `World.EquipFromInventory`
- **Why it's a problem:** When replacing an equipped item, the function removes the old gear via `MutateEquipment` and immediately tries to push that item back into the player's inventory. If `Inventory.AddStack` fails (e.g., bag is full or stack metadata mismatches) the error is ignored because the helper discards the return value from `w.mutateActorInventory`. The player loses the unequipped item and their stats have already been decremented, leaving state inconsistent with what the UI shows.

## 3. Join retry timer keeps firing after a successful reconnect
- **File(s):** `client/network.js`
- **Code:** `joinGame` (error retry path)
- **Why it's a problem:** On a failed `/join` request the client schedules `setTimeout(() => joinGame(store), 1500)` without storing the handle. When a later attempt eventually succeeds there is no way to cancel the earlier timer, so the delayed callback will fire and run `joinGame` again even though a live session already exists. That second invocation resets local state, spawns a new player on the server, and can thrash the diagnostics/status UI a few seconds after you thought you were connected.

## 4. Effect trigger dedupe never forgets IDs
- **File(s):** `client/network.js`
- **Code:** `queueEffectTriggers`
- **Why it's a problem:** The client tracks processed trigger IDs in `store.processedEffectTriggerIds`, but the set is never prunedâ€”entries survive after the trigger has been consumed. Because the server reuses deterministic IDs (it forwards the trigger's `ID`, often derived from effect IDs), any future trigger that reuses that identifier will be dropped on the floor by the client. Long-lived sessions eventually stop playing certain visual triggers even though the server continues to emit them.
