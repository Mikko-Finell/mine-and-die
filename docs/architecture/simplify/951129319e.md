# Simplification Opportunities

## Item 1: Consolidate path-following for players and NPCs
- **Files**: `server/player_path.go`, `server/npc_path.go`
- **Code**: `advancePlayerPaths` / `followPlayerPath` / `ensurePlayerPath` family and their NPC equivalents
- **Proposal**: Extract a shared path-following helper that handles stall detection, arrival radius defaults, and intent updates so both players and NPCs reuse the same implementation with entity-specific hooks for things like clamping the target or writing intents.
- **Reasoning**: Both files reimplement the same loop for iterating waypoints, monitoring `PathStallTicks`, recalc thresholds, and finishing or clearing paths. Keeping two copies doubles the surface for bugs (e.g., NPC `ArriveRadius` default is hardcoded while players use `defaultPlayerArriveRadius`) and makes any behavioural tweak require edits in two places. A unified helper would reduce maintenance drag and prevent the code paths from drifting apart.

## Item 2: Merge duplicated inventory mutation entrypoints
- **Files**: `server/world_mutators.go`
- **Code**: `MutateInventory`, `MutateNPCInventory`, and the shared `mutateActorInventory`
- **Proposal**: Replace the separate player- and NPC-specific wrappers with a single `MutateInventory` that resolves the entity by ID (mirroring `MutateEquipment`) and delegates to `mutateActorInventory` with the right patch kind. The old player-specific helper can become a thin alias to keep call sites compiling during the transition.
- **Reasoning**: Both public functions perform the same nil checks, lookup logic, and call to `mutateActorInventory`, differing only by which map they read from and which patch kind they pass. The duplication makes it easy to forget to handle a new entity type or behaviour change in both paths. A shared entrypoint simplifies the API and guarantees consistent patch emission for inventory mutations.

## Item 3: Collapse duplicated effect spawn classifiers
- **Files**: `client/network.js`
- **Code**: `isBloodSplatterSpawn` / `isFireSpawn` / `isAttackSpawn` / `isMeleeSwingSpawn` and their matching `shouldLog*` helpers
- **Proposal**: Introduce a generic helper that extracts all candidate identifiers from an effect spawn once, then check them against a provided predicate or lookup table. The logging helpers can share another wrapper that validates the message type and runs the classifier. Each concrete effect would then register the predicate instead of reimplementing the same traversal.
- **Reasoning**: Every classifier builds the same `candidates` array by walking `definition`, `type`, and `instance` structures before running a type-specific comparison. Any schema tweak (new field, renamed property) currently needs edits in four near-identical functions. Centralising the traversal will shrink the file, eliminate the risk of behaviour drift, and make it cheaper to support additional effect categories.

## Item 4: Unify inventory stack draining logic
- **Files**: `server/inventory.go`
- **Code**: `RemoveAllOf`, `RemoveItemTypeQuantity`, and the shared `RemoveQuantity`
- **Proposal**: Factor the backward iteration and slot reindexing into a single helper (e.g., `drainMatchingStacks`) that accepts a predicate or remaining budget. Both public functions can call it with different exit conditions, while `RemoveQuantity` stays the low-level primitive.
- **Reasoning**: The two higher-level removals repeat the same reverse loop, check for `slot.Item.Type`, and call `RemoveQuantity`, each re-implementing how to accumulate removed stacks and when to stop. Centralising the traversal reduces off-by-one risk, keeps slot reindexing consistent, and makes future features like partial filters easier to add.
