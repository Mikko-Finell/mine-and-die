# Simplification Opportunities

## 1. Consolidate effect spawn classification helpers

- **File(s):** `client/network.js`
- **Code:** `isBloodSplatterSpawn`, `isFireSpawn`, `isAttackSpawn`, `isMeleeSwingSpawn` (and their `is*Identifier` helpers)
- **Proposal:** Extract a shared helper that collects all candidate identifiers from a spawn payload and performs a case-insensitive comparison against a supplied target set. Each specific classifier can then call the helper with its target label instead of duplicating the property traversal.
- **Rationale:** Every classifier repeats the same traversal of `definitionId`, `type`, `typeId`, nested `definition`, and nested `instance` fields to build an array of strings before lowercasing and comparing. Maintaining four near-identical copies means any contract tweak (e.g., a new field name) must be changed in multiple places and increases the risk of them diverging. A single helper would reduce ~60 lines of duplication and make it much easier to add or adjust tracked effect categories.

## 2. Unify lifecycle batch array extraction

- **File(s):** `client/effect-lifecycle.js`, `client/network.js`
- **Code:** `normalizeLifecycleBatch` (effect lifecycle) and `collectEffectSpawnEvents`
- **Proposal:** Introduce a shared utility (e.g., `readLifecycleArray(payload, snakeKey, camelKey)`) that handles the dual snake_case/camelCase property lookup for lifecycle arrays. Both the lifecycle normalizer and the network bridge can then reuse the helper instead of embedding identical ternary chains.
- **Rationale:** Both modules reach into payloads to select between `effect_spawned` vs `effectSpawned` (and the analogous update/end keys). Copying the same `Array.isArray(...)? ... : Array.isArray(...)? ... : []` logic makes it easy for the two call sites to drift or forget to support a new alias. A common helper would remove repeated branching, centralize the compatibility behaviour, and simplify future payload tweaks.

## 3. Drop optional pointer pattern from resync policy

- **File(s):** `server/resync_policy.go`, `server/patches.go`
- **Code:** `resyncPolicy` struct and its `noteEvent`, `noteLostSpawn`, `evaluate`, `consume` methods
- **Proposal:** Store the `resyncPolicy` value directly on `Journal` (and any other owners) instead of as a pointer, and update the methods to operate on the value receiver. That lets us delete all the `if p == nil { return }` checks and eliminates the impossible "nil policy" state.
- **Rationale:** `newJournal` always initializes `resync` via `newResyncPolicy()`, so callers never intentionally pass `nil`. The current pointer approach adds nil-guard boilerplate to every method and obscures the actual logic. Using value semantics would make the policy always-present, reduce branching, and make the code easier to reason about when adding future thresholds or counters.

## 4. Factor repeated world reset option wiring

- **File(s):** `server/main.go`
- **Code:** `/world/reset` handler's `resetRequest` parsing block
- **Proposal:** Replace the sequence of `if req.Field != nil { cfg.Field = *req.Field }` assignments with helper functions (e.g., `applyOptionalBool`, `applyOptionalInt`) or iterate over a table of setters. This would shrink the handler, make new fields easier to add, and avoid subtle inconsistencies like missing normalization when a new option is introduced.
- **Rationale:** The handler currently repeats the same nil-check + assignment pattern for a dozen request fields, with a nested block for NPC counts. The duplication is noisy and easy to get wrong when the reset payload evolves. A small helper layer would centralize the optional assignment behaviour, keeping the handler focused on the exceptional rules (like splitting NPC counts) and making the codebase simpler to maintain.

