# Server Architecture

The Go service owns the authoritative world state and exposes three responsibilities:

1. **Session management** – `/join` creates players, `/ws` streams updates, and `/diagnostics` surfaces runtime metrics.
2. **Simulation** – a fixed-rate tick loop advances movement, effects, and collision cleanup.
3. **Static hosting** – the root handler serves the `client/` directory.

## Core Packages and Types
- `main.go` – HTTP handlers, WebSocket wiring, and process bootstrap.
- `hub.go` – `Hub` implementation, player/session lifecycle, command queue, simulation ticker, and broadcast helpers.
- `simulation.go` – `World` data model plus the per-tick command processor and effect systems.
- `effects.go` – Ability cooldowns, projectile movement, environmental hazards, and shared effect behaviours.
- `inventory.go` – Item definitions plus helper methods for stacking, moving, and cloning player inventories.
- `npc.go` – Neutral enemy types and snapshot helpers.
- `messages.go` – Wire payload contracts.
- `main_test.go` – Behavioural tests covering joins, intents, effects, and heartbeat handling.
- Dependencies: only the Go standard library plus `github.com/gorilla/websocket`.

### Hub Overview
The `Hub` struct keeps simulation concerns isolated from transport:
- `world` – pointer to the authoritative `World` instance that owns players, NPCs, effects, and obstacles.
- `subscribers` – active WebSocket connections keyed by player ID.
- `pendingCommands` – slice of staged simulation commands populated by HTTP/WebSocket handlers.
- Atomic counters for player IDs (`nextID`) and the current simulation tick (`tick`).

`newHub()` seeds a fresh `World` with generated obstacles and NPCs, ready to accept joins.

### Command Flow
Network handlers never mutate actors directly. Instead they enqueue typed `Command` structs:
- `CommandMove` stores normalized intent vectors and optional facing overrides from `UpdateIntent`.
- `CommandAction` captures action strings from `HandleAction` (melee, fireball, etc.).
- `CommandHeartbeat` records connectivity metadata and round-trip times from `UpdateHeartbeat`.

The queue is drained at the start of each tick so every command is applied exactly once in submission order.

### Tick Loop
`RunSimulation` spins a `time.Ticker` at `tickRate` (15 Hz). Each tick:
1. Calls `advance` with the elapsed delta so the world can process staged commands.
2. Closes subscriber sockets for players removed by the simulation (missed heartbeats, disconnects).
3. Broadcasts the latest snapshot via `broadcastState`.

`advance` locks the world, calls `World.Step`, and returns the new snapshot alongside the list of subscribers to disconnect.

### World & Simulation Systems
`World.Step` is the heart of the simulation. Given the tick index, wall-clock time, delta seconds, and drained commands it:
- Updates player intents, facings, and heartbeat metadata from queued commands.
- Derives NPC intents via the A* path follower, then advances movement for players and NPCs against obstacles before resolving actor collisions.
- Stages abilities triggered by commands and executes their effects (melee swings, fireballs).
- Applies environmental hazards such as lava pools as damage-over-time.
- Advances and prunes effect lifecycles plus awards ore mining loot.
- Removes players whose last heartbeat is older than `disconnectAfter`.

### Fire-and-forget Effect Triggers
The hub tracks two effect collections when serialising a snapshot:
- `effects` – Active hitboxes or projectiles that still need per-tick updates.
- `effectTriggers` – One-shot events generated by helpers such as `QueueEffectTrigger`.

`Hub.advance` flushes the trigger queue every tick and sends the resulting array alongside
the standard snapshot so combat systems can publish transient visuals without keeping
placeholder effects alive. Consumers enqueue triggers while holding the hub mutex; the
next broadcast includes them once and then discards them server-side. The flow lets the
server hand off animations or decals to the client while the authoritative simulation
stays focused on active state.

### Deterministic Randomness
- `worldConfig.Seed` controls all pseudo-random behaviour. The default seed is `"prototype"`, but the client debug panel can POST a new value when restarting the world.
- Subsystems derive independent RNG streams from the root seed (e.g. `obstacles.base`, `obstacles.gold`, `world`) so obstacle layouts, ore positions, and AI randomness stay reproducible.
- Providing the same seed to `/world/reset` regenerates an identical world and AI behaviour, which keeps QA scenarios repeatable across sessions.

### Neutral Enemies
- NPCs reuse the shared `Actor` struct for position, facing, health, and inventories, and add fields like `Type`, `AIControlled`, and `ExperienceReward`.
- `spawnInitialNPCs` seeds multiple archetypes: goblins patrol fixed waypoints with lootable inventories while rats wander their den and flee when non-rat actors intrude. Additional spawns append `npcState` entries within the world's mutex-protected sections.
- Snapshots include a `npcs` array alongside the existing `players`, enabling the client to render and later target neutral enemies without special casing.

### Actions, Health, and Cooldowns
`World.Step` invokes action helpers based on staged commands:
- Melee swings: `triggerMeleeAttack` spawns a short-lived rectangular effect, records cooldown, damages overlapping players, and awards one gold coin when the hitbox overlaps gold ore.
- Projectiles: `triggerFireball` delegates to the projectile template registry, `advanceProjectiles` applies movement/collision rules, and templates can spawn follow-up area effects on impact or expiry.
- Hazards: lava pools generated by `generateObstacles` are ignored by collision checks but burn actors standing inside them via `applyEnvironmentalDamage`.

Players track `Health` and `MaxHealth`. Effect helpers share the `Effect` struct (`type`, `owner`, bounding box, `Params`) sent to clients. Behaviours are registered in `effectBehaviors`; melee swings and projectile templates publish `healthDelta` parameters applied to every overlapping target. Positive values heal (clamped to `MaxHealth`), negative values deal damage.

### Inventory System
- Each `Player` carries an `Inventory` composed of ordered slots. The ordering is preserved in snapshots so clients can surface drag-and-drop later on.
- `ItemStack` values automatically merge when the same `ItemType` is added twice, supporting infinite stacking for resources like gold.
- `Inventory.MoveSlot` and `Inventory.RemoveQuantity` centralize reordering and stack splitting logic. Both operate while holding the hub mutex to keep state consistent.
- `Inventory.Clone` is used when broadcasting player snapshots to avoid data races between the simulation and JSON encoding.

### Ground Items & Console Commands
- The hub tracks a single `GroundItem` stack per tile (`groundItems` plus a tile index) so repeated drops merge automatically.
- Ground gold is exposed alongside other snapshot arrays (`state.groundItems`) and included in `/join` responses so fresh clients immediately render existing piles.
- Players (and NPCs) automatically drop their entire gold inventory when their health reaches zero; the stack spawns on the corpse tile using the shared merge rules.
- Two debug-only console commands exist for manual testing over WebSocket: `drop_gold` (requires a positive quantity not exceeding the carried amount) and `pickup_gold` (grabs the nearest stack within one tile radius). The server validates requests while holding the hub mutex to guarantee deterministic outcomes.
- Successful console commands include the affected ground stack ID in their acknowledgement payloads so clients can correlate logs or overlay highlights with the authoritative entity.
- `logging/economy` emits `economy.gold_dropped`, `economy.gold_picked_up`, and `economy.gold_pickup_failed` events so QA can audit transfers.

### Heartbeats and Diagnostics
- Clients send `{ type: "heartbeat", sentAt }` ~every 2 seconds.
- `UpdateHeartbeat` enqueues a heartbeat command recording the receipt time and RTT so the simulation can update `playerState` records during the next tick.
- `DiagnosticsSnapshot` returns minimal player heartbeat info for the `/diagnostics` endpoint.

### HTTP Endpoints
- `POST /join` – allocate a player, return `{ id, players, obstacles, effects }` snapshot.
- `POST /world/reset` – rebuild the world using the supplied `{ obstacles, npcs, lava, seed }` toggles and broadcast the new snapshot to all players. Leaving `seed` blank falls back to the default deterministic seed.
- `GET /ws?id=...` – upgrade to WebSocket; first message is an immediate state snapshot.
- `GET /diagnostics` – JSON payload with tick rate, heartbeat interval, and per-player metrics.
- `GET /health` – simple liveness string.
- `GET /` – static file server rooted at `client/`.

### Extending the Server
- Add new player fields within `Player`/`playerState` and include them in `snapshotLocked`.
- Register new actions in `HandleAction` and encode behaviour in dedicated helpers.
- Extend `Effect.Params` for additional metadata—clients simply mirror the JSON.
- Spawn new NPC types by creating `npcState` records and adding them to `Hub.npcs` under the mutex.
- Preserve locking discipline: acquire `Hub.mu` before touching shared maps/slices.
- Update or add tests in `main_test.go` whenever gameplay rules change.

### Testing
Run `go test ./...` from the repository root or within `server/`. The suite focuses on:
- Join flow and snapshot integrity.
- Intent normalization and facing resolution.
- Movement clamping, obstacle avoidance, and player separation.
- Melee/projectile effect creation and cooldown enforcement.
- Heartbeat tracking and diagnostics output.
